# auditd_parser

## 注意事项

### 关于输入/输出重定向

从[此提交](https://github.com/petitfleur/LogParser/commit/4ab8ad049f3a9f0ddb601fb470ef5950bcbdbc45)起，auditd_parser 可以正确处理标准输入/输出/错误流被重定向的状况。下面结合终端进行重定向的过程进行分析（测试环境 `zsh` on `Ubuntu 22.04`）：
1. 终端通过 `fork()` / `clone()` 生成子进程。
2. 终端打开重定向目标，通过 `dup2()` / `dup3()` 重映射到被重定向的流，再关闭此目标文件。
3. 终端通过 `exec()` 执行程序。

代码示例：
```c
if (fork() == 0) {
    int fd = open("file", ...);  // 例如，fd = 3
    if (dup2(fd, 1) < 0) {
        // error...
    }
    // 现在 fd 3 和 1 都指向 file，原来 1 指向的 stdout 已经被关闭
    close(fd);
    exec(...);  // 执行的程序对 stdout 的写入重定向到了 file
} else {
    // 父进程等待子进程完成...
}
```

解析上述操作日志的过程：
1. 对于 `fork()` 出的子进程，解析器会从父进程复制 fd 映射表，其中 1 对应 `stdout`。
2. 解析器发现 `dup2()` 时，将映射表中 1 对应的文件设置为 3 对应的文件，即 `file`，`stdout` 被替换掉了。
3. 子进程操作（在它看来的）`stdout` 时，解析器通过映射表找到对应的文件 `file`。
4. 子进程操作完（在它看来的）`stdout` 后将其关闭，映射表中 1 没有对应的映射。经实验这是符合实际情况的，也即系统不会自动在 1 上重新打开 `stdout`。
5. 父进程的映射表不受影响，1 仍然对应 `stdout`。

需要注意的是，由于关键的 `dup2()` 调用发生在 shell 中，因此在采集日志时必须将 shell 纳入采集范围，不能只采集执行的那个程序。